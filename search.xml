<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[你有我的知识焦虑么？]]></title>
    <url>%2F2018%2F01%2F28%2F%E4%BD%A0%E6%9C%89%E6%88%91%E7%9A%84%E7%9F%A5%E8%AF%86%E7%84%A6%E8%99%91%E4%B9%88%2F</url>
    <content type="text"><![CDATA[”知识焦虑“ 在信息爆炸时代，人们对信息的吸收是呈平方数增长，但面对如此大量的信息，人类的思维模式远没有高速到接受自如的阶段。由此造成一系列的自我强迫和紧张。 我相信我们现处的这个时代，很多人跟我一样，都有一份“知识焦虑”，对自己未知的信息和知识，给予了自己的自我强迫与紧张。面对自己的不努力，懒惰懈怠，都会有或多或少的一份不安全感与恨其不争的无奈。懒散过后，又开始信誓旦旦地制定学习计划，希望通过学习课程，读书来让自己的内心变得充实些。 现实中，如果你有个有钱的老爸，让你衣食无忧，光鲜亮丽，些许你会少点焦虑。可惜大多数人如你我，并没有这样足以啃老的臂膀。唯有步履匆匆，用兢兢业业的工作和不敢停歇的学习，来让自己拥有一份份看上去不那么不堪的安全感。因为明白，不学习不努力就意味着不拼爹，不拼高考，你已经没有什么可以跟他们比拼的了。 但是，你的努力真的对了么？？？你在背的雅思英语，你在看的MBA，你在看的成功学。真的适合你么？？？ 改变你的思维认知 “立场，体验，意见” —— “目标，方法，行动” 思维方式的转变，我们每一个人的大脑里总会产生各种天马行空的想法或创意，每个人有不同的个人体验和对事物的意见。但是真正落实实践自己想法，行动起来的却少之又少。 投资界有这么个故事，投资人考核一家初创公司，不是看公司第一把手，而是看公司的第二把手。因为公司第一把手大多是公司创意想法的制造者，而公司第二把手则是执行者，如果执行者能力足够胜任，那么证明这家公司可行。因为第一把手已经成功地推销了自己的想法，并且得到其它牛人的认可，并且确保可以正确有效地执行。那么公司可以成功地运营起来。初创公司空有想法创意，不能有效执行实施，终究是空谈。 我们的思维方式来自从小的生活环境，父母，学校，家庭的耳濡目染。更多的是来自父母，“富爸爸，穷爸爸”的思维方式，把父辈的那一套思维方式传递给了我们。 随着“阶层危机”的到来，让社会阶层越来越固化，平民阶层与上层阶层的界限，除了资源的比拼，更深层次地是思维认知的差距。“富爸爸，穷爸爸”不是现金存款房车的比拼，而是比拼贫富的思维认知。“贫穷限制了你的思维”这并不是一句调侃的话，而是鲜血淋漓的写照。 想改变你所处的阶层，想从平民阶层晋升到上层阶层，唯有从改变你的思维认知开始，让你的思维完成从“立场，体验，意见”到“目标，方法，行动”转变。使你的思维认知不再处于贫穷。 “体验型消费”如果你没有知识，出去旅游看见美丽的风景，你只会说“哇靠，太美了”。而有知识的人，当你看到夕阳余晖… 你的脑海浮现的是：“落霞与孤鹜齐飞，秋水共长天一色。” 而不是：“卧槽，好多鸟，好多鸟，卧槽，真TM太好看了！”没有文化积淀的旅行，到哪不过是在你的相机中多留几张照片而已。作为一个俗人，欣赏它的美并不需要任何的门槛。但是没有文化知识的积淀，你就只是在走马观花，到此一游。 学习方法知识量爆发式增长，知识付费的兴起，各种在线音视频课程，公众号课堂雨后春笋般增长，人们获取知识的成本越来越低。但与之对比是人们的时间却被剧烈分割，时间一点一点被碎片化。不再拥有像学校课堂里，让你整整45分钟坐在课桌前，学完一学期的课程。知识量与学习时间成反比增长，传统的、系统化的学习方法已经不再有效。我们所处的时代，有太多的诱惑纷扰我们的集中力，很多人时不时地去看手机，一刷个朋友圈，一看个头条微博，大半的时间就这样不翼而飞。强迫你拿着本书从头看到尾，这样耗时，又学不牢，估计看完了也就完了，又剩下多少是你自己的。 因此，如何利用有限的时间来完成自己的知识储备，对当下的我们尤为重要。 1. 20%的时间学习80%的知识80%的知识并不难学会，但是剩下20%的进阶知识往往需要花费更多的时间精力才可并入囊中。鉴于投入与产出成正比，20%的时间换取80%的知识显然更符合当下，学习过后通过转述或者读书笔记加深自己的理解和记忆，变成自己的知识储备。 2. 找一个牛人，跟着他学自己摸索前行，总有很多荆棘。避免少走弯路，我们缺少一个领路人。而行业/知识领域界的大牛，他就是我们想要到达的终点，也是我们学习的参考对象。跟着他学，我们将知道自己所要学习哪些知识，朝哪个方向努力，有哪些坑需要跳过。有人给你指明了前方的路，你更容易到达，这样焦虑负担相对小了些。 3. 先搭建概念大厦，再具体学习我们对于未知的知识或多或少都有抗拒，如果一开始就抗拒，不利于你去接受认可它。学习新知识，可以先了解新知识各种概念名词，再去细化具体每个概念的基础学习。正如我们手中拿起一本未读过的书，先翻阅目录，了解每个章节的概念名词，再去翻阅具体每个章节的知识。减少来自我们自身的抗拒，并在脑海中构建起新知识的骨架，再一点点拼积木完成学习积累。 从自身做出改变，总是一件很难很难的事情。但是一点点的不同，都是对自身努力的一次美好见证。愿你我终有所得。]]></content>
      <categories>
        <category>日更文集</category>
      </categories>
      <tags>
        <tag>日更文集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac终端配置，DIY你的Terminal（iTerm2 + Oh-My-Zsh）]]></title>
    <url>%2F2018%2F01%2F10%2FMac%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%8CDIY%E4%BD%A0%E7%9A%84Terminal%EF%BC%88iTerm2-Oh-My-Zsh%EF%BC%89%2F</url>
    <content type="text"><![CDATA[使用mac osx一年以来，自带的Terminal终端一直都是白底黑字，食之无味，越来越缺乏新鲜感，怎么也得想个法子来刺激下眼球。不然花那么多大洋买你回来是要哪般，难道真是为来学习工作？？？怎么可能，不装逼谁TM买苹果。。。好吧，其实为来工作学习，装逼纯属业余。 完成配置后的终端具备功能： 语法高亮 命令行tab补全 自动提示符 显示Git仓库状态等功能 ⌘+r 快速清空代码面板，跟终端输入clear一样的效果 安装步骤1. 下载iTerm22. 解压后安装iTerm2并打开 iTerm2 -&gt; Make iTerm2 Default Term 打开偏好设置preference，选中Keys，勾选Hotkey下的Show/hide iTerm2 with a system-wide hotkey，将热键设置为 ⌘+. ，这样你就可以通过 ⌘+. 全局热键来打开或关闭iTerm2窗口，非常方便3. 配色方案选用 solarized，下载解压，然后打开 iTerm2 下的偏好设置 preference ，点开 profiles 下的colors 选项，点击右下角的 Color Presets 选项，选择import ，导入解压到的 solarized 文件下的Solarized Dark.itermcolors 4. 安装oh-my-zshgithub：https://github.com/robbyrussell/oh-my-zsh官方提供 curl 和 wget 两种安装方式curl 安装：sh -c ``&quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;wget安装：sh -c ``&quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 5. 配置主题安装oh-my-zsh成功后 用 vim 编辑隐藏文件 .zshrc， 终端输入vi ~/.zshrcZSH_THEME=&quot;agnoster&quot; 将zsh主题修改为“agnoster” 应用“agnoster”主题需要特殊的字体支持，否则会出现乱码情况，使用 Meslo 字体，点开链接点击 view raw 下载字体 安装字体到系统字体册 在iTerm2中应用字体 iTerm -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Change Font） 重新打开iTerm2窗口（或新打开一个iTerm2窗口）即可以看到字体效果 6. 自动提示与命令补全比iTerm2自带的更强大的命令提示与补全 克隆仓库到本地 ~/.oh-my-zsh/custom/plugins 路径下git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 用 vim 编辑 .zshrc 文件，找到插件设置命令，默认是 plugins=(git) ，我们把它修改为plugins=(zsh-autosuggestions git) PS：当你重新打开终端时可能看不到变化，可能你的字体颜色太淡了，我们把其改亮一些： cd ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions 用 vim 编辑 zsh-autosuggestions.zsh 文件，修改ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=&#39;fg=10&#39; 7. 语法高亮效果 使用homebrew包管理工具安装 zsh-syntax-highlighting 插件brew install zsh-syntax-highlighting如果电脑上还没有安装homebrew，请先安装homebrew/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 配置.zshrc文件，插入一行source /xxx/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh(注意： /xxx/ 代表.zshrc所在的路径) 加载.zshrc配置source ~/.zshrc 重新打开iTerm2窗口（或新打开一个iTerm2窗口）即可以看到效果 扩展 iTerm2 默认使用dash改用zsh解决方法：chsh -s /bin/zsh iTerm2 zsh切换回原来的dash：chsh -s /bin/bash 卸载oh my zsh，在命令行输入：uninstall_oh_my_zsh 路径前缀的XX@XX太长，缩短问题：编辑~/.oh-my-zsh/themes/agnoster.zsh-theme主体文件，将里面的build_prompt下的prompt_context字段在前面加#注释掉即可 作者：以乐之名本文原创，有不当的地方欢迎指出。转载请指明出处。]]></content>
      <categories>
        <category>工具类</category>
      </categories>
      <tags>
        <tag>工具类</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序爬坑日记]]></title>
    <url>%2F2017%2F12%2F08%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%88%AC%E5%9D%91%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[新公司上手小程序。30天，从入门到现在，还没放弃。。。 虽然小程序发布出来快一年了，爬坑的兄弟们大多把坑都踩平了。而我一直停留在“Hello World”的学习阶段。一来没项目，只有项目才是实践学习的根本；二来刚出来，总是有很多坑。爬坑总是痛并快乐着。 再多的借口，产品项目需求拍在桌前，都得缴械投降。不要怂撸起袖子，就是干。 初识小程序微信推出小程序，想要实现即开即用，用完即走的用户体验。免去APP下载安装繁琐的流程。听起来像谷歌推出的PWA，不过PWA普及到国内还有段时间。而小程序借助于微信的用户群体，植入成本低，容易被用户接受。 小程序的代码风格跟Vue其实挺像，对于习惯Vue开发模式的同学，上手并没有太大的问题。 小程序不支持前端主流框架，如Vue，Angular，React，jQuery等，而且小程序有自己的一套视图容器(Dom)的写法，跟平常我们在web上写HTML不一样。不过CSS3那些变化不大。虽然文件名改成了(.wxss) 本司项目，使用webpack做打包工具，将代码编译成符合小程序的代码目录规范，采用wechat-mina-loader插件，实际开发起来跟在Vue下开发习惯一样。babel完成ES6转ES5，sass编译，压缩转化等工作都放到webpack中去做。 不支持dom操作小程序脚本内不能使用window,document对象，所以无法操作dom。如果想操作节点，可用wx.createSelectorQuery() 另外数据驱动的开发模式，跟Vue相同，只是写法换了（vue: v-if，小程序: wx:if） rpx布局 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 设计师做设计图以iPhone6作为设计稿基准就可以，基本上可以用rpx替换px，不过在一些表单或者提示页面，使用设计稿上的rpx会让小屏幕手机看着尺寸略小，提示页面可参照weui用px来实现 路由层级 wx.navigateTo(OBJECT)保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面 wx.redirctTo(OBJECT)关闭当前页面，跳转到应用内的某个页面 wx.switchTab(OBJECT)跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面 wx.reLaunch(OBJECT)关闭所有页面，打开到应用内的某个页面 小程序只能同时打开打开5个页面，当打开5个页面后，wx.navigateTo不能正常打开新页面，请避免多层级的交互方式，或者使用wx.redirctTo重定向 tabBar底部导航栏tabBar是一个数组。配置最少2个，最多5个，tab数组按顺序排序 页面滚动到顶部基础库1.4.0支持123wx.pageScrollTo(&#123; scrollTop: 0 //滚动到页面的目标位置（单位px）&#125;) 图片资源，CSS中的背景图片CSS中无法使用本地资源(开发目录中)的图片作为background-image。可以使用网络图片资源，或base64，或者使用image标签。tabBar的icon资源可使用本地资源 unionid与openid的区别每个用户在每个小程序里面都有唯一的openid，如果想在多个公众号，小程序里面共享用户信息，统一识别该用户，则需要用到unionid。为了获取uniond则需要注册微信开放平台，将需要共享的小程序，公众号进行绑定（不超过10个，超过10个还要申请认证称为第三发平台）。 textarea在滚动页面中的bugtextarea,map等组件是由客户端创建的原生组件，它的层级是最高的。如果有遇到定位元素的话。永远在最上面，盖不住。 请勿在 scroll-view、swiper、picker-view、movable-view 中使用 textarea 组件 CSS动画对textarea无效 项目场景：页面底部固定了一个按钮（position:fixed), 页面滚动时，textarea总是在按钮上面，点击按钮就点到了textarea 可以设置网络请求的超时时间app.js中配置123&quot;networkTimeout&quot;: &#123; &quot;request&quot;: 10000 // 10秒&#125; window配置navigationBarTextStyle 导航栏标题颜色仅支持black/white状态栏，导航条，标题，窗口背景色支持纯色，不支持渐变色 参数问题 url中添加参数，如url?a=1&amp;b=2, onLoad(options) options.query.a, options.query.b可获取到 扫描小程序码进页面，如果想获取小程序码url中所带的参数，可通过options.scene获取，不过需要对二维码中的scene值进行转换decodeURIComponent(options.scene), 调试阶段可以使用开发工具的条件编译自定义参数 scene=xxxx 进行模拟，开发工具模拟时的 scene 的参数值需要进行 urlencode (启动参数：scene=n%3D1001) 实际为scene=n=1001，参数n=1001 image标签图片image默认width: 300px, height: 225px, lazy-load懒加载只对page与scroll-view下的image有效mode缩放模式，mode=”widthFix”比较常用(宽度不变，高度自动变化，保持原图宽高比不变) 小程序可以监听小程序的关闭后，但是无法阻断场景：想在小程序退出时弹出个提示框，并阻止关闭（暂时无法实现） 小程序码小程序码(葵花码)有几种方式，只有发布过小程序才可正常显示小程序码 小程序第一次提交的审核时间较后面的长第一次提交审核一般1天到2天。所以为了能准点上线，建议先上一次临时的版本(放一个提示页面都可以)，过了第一次审核发布再说。日常提交审核，2-3小时就可以。 频繁地setData会造成性能问题频繁地setData操作，会出现卡顿，操作反馈延迟严重，甚至有可能闪退。 场景：原计划用countUp做数字动画，原理就是频繁地改变数字值，setData操作，渲染到模版上。 ES6转ES5，小程序检测目录中的js文件(极少)项目中用了webpack进行ES6转ES5，所以关闭了微信小程序的ES6转ES5功能。这个坑就比较隐蔽了，测试的时候在5S真机上报js错误，发现有个js(使用了ES6，没有转ES5)文件没有使用，微信小程序会去检测目录中的js文件，如果关闭了微信自带的ES6转ES5，检测到目录中js文件不兼容ES5，就报错。这个Bug只在5S真机里出现过，5C都正常。如果开启了微信开发工具中的ES6转ES5，则会自动帮你完成转化工作，不会出现类似问题。 分享些小程序开发比较常用的第三方库 weui-wxss(小程序版的weui样式库) Github: https://github.com/Tencent/weui-wxss wepy(小程序组件化框架) Github: https://github.com/Tencent/wepy skyvow/vux(小程序组件库) Github: https://github.com/skyvow/wux xiaolin3303/wx-charts(小程序图标) Github: https://github.com/xiaolin3303/wx-charts 作者：以乐之名 本文原创，有不当的地方欢迎指出。转载请指明出处。]]></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>WEB 微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm常用命令整理]]></title>
    <url>%2F2017%2F10%2F04%2Fnpm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[npm是一个NodeJS包管理跟分发工具，已经成为了非官方的发布node模块（包）的标准。它可以帮助我们解决代码部署上的一些问题，将开发者从繁琐的包管理工作中(版本、依赖等)解放出来，更加专注于功能上的开发，大大提升我们的工作效率。 以下为日常应用中收集整理的npm常用命令: 初始化 引导你创建一个package.json文件npm init 查看package.json文件内容格式npm help json 安装模块 (install 可简写为 i)npm install moduleName(安装到当前目录，仅在当前目录可用) 全局安装npm install moduleName -g(全局安装，可在所有目录下使用) 安装package.json中的模块npm install(目录中存在package.json，将安装package.json配置号的版本模块，install后面可不带模块名) 安装到开发环境依赖npm install moduleName --save-dev(例如一些预编译包，如sass-loader,less-loader等，仅在开发环境中会用到) 安装到生成环境依赖npm install moduleName --save 卸载模块 (uninstall 可简写 un)npm uninstall moduleName 重新安装模块npm rebuild moduleName 查看帮助npm help 检查模块是否已经过时npm outdated（列出所有有新版本的模块，方便对包的更新） 检查npm线上是否存在该模块npm search moduleName（当你想要发布自己写的包时，需查看线上是否有同名的已发布的包） 查看当前目录模块的安装路径npm root 查看全局安装模块的安装路径npm root -g 查看npm安装的版本npm -v 更新本机npm的版本npm install -g 更多npm命令请查看NPM官方文档 作者：以乐之名本文原创，有不当的地方欢迎指出。转载请指明出处。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>WEB</tag>
        <tag>Javascript</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[preventDefault,stopPropagation,return false三者的区别]]></title>
    <url>%2F2017%2F08%2F31%2FpreventDefault-stopPropagation-return-false%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[逛帖子的时候看到道友发的前端面试题， preventDefault(), stopPropagation(), return false三者的区别 这三者的使用想必大家并不陌生，但是细想之下还是有可究之处。 preventDefault()阻止元素在浏览器中的默认行为1234&lt;a id=&quot;link&quot; href=&quot;http://wuliv.com&quot;&gt;网站&lt;/a&gt;$(&apos;#link&apos;).click(function(event)&#123; event.preventDefault(); // 阻止了a链接href的访问或跳转&#125;) stopPropagation()事件冒泡：当一个元素上的事件被触发时，比如鼠标点击了一个按钮，同样的事件将会在该按钮元素的所有父级／祖先元素上触发。这一个过程就被称为事件冒泡。它是由子级元素先触发，父级元素后触发，由内而外（由下往上）的一个流程。与之顺序相反的是事件捕获。 事件捕获：父级元素先触发，子级元素后触发，在此仅做了解。 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id=&quot;inner&quot;&gt; &lt;p&gt;事件冒泡例子&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;我要弹个框&lt;/button&gt; &lt;/div&gt;&lt;/div&gt;$(&apos;#btn&apos;).click(function(event)&#123; event.stopPropagation(); // 阻止了事件冒泡，不会触发&quot;#inner, body&quot;的点击事件 console.log(&apos;#btn&apos;)&#125;)$(&apos;#inner&apos;).click(function(event)&#123; // #btn 阻止了冒泡，这里不会执行 // 如果不使用stopPropagation, 当#btn点击时，这里也会执行 console.log(&apos;#inner&apos;)&#125;)$(&apos;body&apos;).click(function(event)&#123; // #btn 阻止了冒泡，.btn点击不会影响到我 // 如果不使用stopPropagation, 当#btn点击时，这里也会执行 console.log(&apos;body&apos;)&#125;)// 使用了stopPropagation()输出&apos;#btn&apos;// 不使用stopPropagation()输出&apos;#btn&apos;&apos;#inner&apos;&apos;body&apos; stopImmediatePropagation()阻止对象绑定的剩余的事件处理函数方法的执行，并阻止当前事件的冒泡。可以理解为stopImmediatePropagation是stopPropagation的升级版，除了阻止冒泡，还能阻止结束掉当前对象未执行的其它绑定事件方法。 jQuery中一个对象可以绑定多个事件方法，执行顺序会按照绑定的先后顺序来执行 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;div id=&quot;inner&quot;&gt; &lt;p&gt;stopImmediatePropagation()例子&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;按钮&lt;/btn&gt; &lt;/div&gt;&lt;/body&gt;$(&apos;body&apos;).click(function(event)&#123; // body 点击 console.log(&apos;body&apos;);&#125;);$(&apos;#inner&apos;).click(function(event)&#123; // #inner 点击 console.log(&apos;#inner&apos;);&#125;)$(&apos;#btn&apos;).click(function(event)&#123; // 第一个#btn点击 e.stopImmediatePropagation(); console.log(&apos;#btn 1&apos;);&#125;)$(&apos;#btn&apos;).click(function(event)&#123; // 第二个#btn点击 console.log(&apos;#btn 2&apos;)&#125;)// 最终输出&apos;#btn 1&apos; // (因为stopImmediatePropagation阻止了#btn绑定的剩余未执行的事件方法，并且阻止了冒泡)// 如果不使用stopImmediatePropagation， 将输出&apos;#btn 1&apos;&apos;#btn 2&apos;&apos;#inner&apos;&apos;body&apos;同个对象执行顺序按绑定顺序执行，冒泡则由内向外执行 return false“return false” 相信不少同学会用来阻止元素在浏览器中的默认行为，拿它当preventDefault()使用，但其实“return false”做的事情不仅仅只是阻止默认行为 当调用“return false”时，它执行了以下三件事情 event.preventDefault() event.stopPropagation() 停止回调函数执行并立即返回 1，2点还好理解，那么第3点是怎么回事？return语句会终止函数的执行并返回函数的值。所以不管是否返回false或是其它值，return语句后面的代码都不会执行。而返回false，使它具备了preventDefault和stropPropagation的功能 123456$(&apos;a&apos;).click(function()&#123; return false; // return false直接返回了，并不会执行alert alert(&apos;我没有被弹出来&apos;);&#125;)// preventDefault 和 stopPropagation 并不会阻止回调函数的执行 总结很多jQuery教程在代码演示中用“return false”来阻止执行浏览器的默认行为。久而久之，很多同学习惯滥用“return false”来代替preventDefault 大多数情况下，我们仅仅是想要它执行跟preventDefault的功能而已，但它却自作主张地帮你执行了另外两步操作。比较好的编程习惯是，需要用到该事件方法再去调用，否则应该避免冗余事件的执行。就像prevnetDefault完成它该有的工作，并不会阻止父节点继续处理事件，使得代码更加灵活，更易于维护。 日常开发中还是要慎用“return false”，除非你同时需要preventDefault和stopPropagation，并且确定你的回调函数执行完成后调用，那么你可以使用“return false”，否则还是用preventDefault 或 stopPropagation 更好些。 作者：以乐之名本文原创，有不当的地方欢迎指出。转载请指明出处。 参考文章：《preventDefault()、stopPropagation()、return false 之间的区别》]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>WEB</tag>
        <tag>Javascript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP中GET与POST的区别 99%的错误认识]]></title>
    <url>%2F2017%2F08%2F27%2FHTTP%E4%B8%ADGET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB-99-%E7%9A%84%E9%94%99%E8%AF%AF%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本篇文章分两部分，第一部分可以列为初为新人的装逼失败模式，第二部分列为修炼低调模式。装逼失败模式：99%的人对GET和POST的认识修炼低调模式：1%不知道的进阶认识 GET和POST，在我们日常WEB开发中，是最常用的数据传输方式。面试中我们也经常会遇到。一般我们在浏览器输入一个网址URL访问网站都是GET方式请求；在HTML FROM表单中，可以通过设置method指定提交方式为GET或者POST方式，默认为GET提交方式 HTTP定义了与服务器交互的不同方法，其中最基本的四种：GET，POST，PUT，DELETE，HEAD；其中GET和HEAD被称为安全方法，因为使用GET和HEAD的HTTP请求不会产生什么动作。不会产生动作意味着GET和HEAD的HTTP请求不会在服务器上产生任何结果。但是安全方法并不是什么动作都不产生，这里的安全方法仅指不会修改信息。 GET和POST我们比较常用，其它几种实际应用比较少用到，在此仅作了解。 99%的人所认为的GET和POST1. 传输方式（自我理解“显示方式”）GET请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数之间以&amp;连接，如&quot;http://www.xxx.com/product?type=shoe&amp;price=100&amp;sex=male&quot;数据格式有以下注意点： 如果数据是英文字母/数字，原样发送； 如果是空格，转换为+； 如果是中文或其他字符，则把数据用Base64加密，如&quot;%E4%BD%A0%E5%A5%BD&quot;其中％XX中的XX为该符号以16进制表示的ASCII码。 POST请求会把请求的数据放置在HTTP请求包的包体中，GET传输的数据会直接暴露在URL中，而POST请求则不会。 2. 传输数据大小GET方式传输的数据最多只能是1024字节，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系，URL本身不存在参数上限的问题，HTTP协议规范也没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 注意：限制是针对整个URL长度，不单是传输的数据长度。 POST方式理论上没有限制，可传较大的数据。起限制作用的是服务器的处理程序的处理能力。Apache, Nigx, IIS服务器自身可配置限制传输大小。 3. GET在浏览器回退是无害的，而POST会再次提交请求4. GET产生的URL可以作为标签或存于历史记录中，而POST不可以5. GET请求会被浏览器主动cahe，而POST不会，除非手动设置6. 安全性GET传输的数据直接暴露在URL中，如果我们在做用户登录时，需要传输登录帐号及密码到后端做验证，如果用GET方式，那么账户密码直接暴露在URL里面，是极其危险的。而且浏览器缓存的机制，访问过的网站URL会被保存在浏览器历史记录里，其他人可通过历史记录查看访问网站URL，直接获取到传输的数据。很可能受到 “Cross-site request forgery”(中文名称：跨站请求伪造) 攻击。不过POST的数据也是可以被拦截的。 总结： GET请求是用来向服务器发送索取数据的一种请求，实际应用中数据不涉及到安全性，可用GET方式来向后端请求数据，如分页或搜索关键词 &quot;http://www.xxx.com/product?keywords=xxx&amp;page=2&quot;; POST请求是向服务器提交数据的一种请求，涉及到安全性的数据，用POST的方式来传输较GET更安全。 曾经的曾经，我也是那99%的一员，还把自己归纳的文章发给新人同事看，然后装逼失败，被老大引导练成最后的这1%。 1%的人所拥有的GET和POST本质上是没有区别的，它们是HTTP协议中的两种发送请求的方式。HTTP是基于TCP/IP的关于数据如何在万维网中通信的协议，即HTTP的底层是TCP/IP，所以GET和POST的底层也是TCP/IP，也就是说：GET/POST都是TCP链接。给POST带上url参数，给GET加上request body，技术上是可以实现的。 为了更方便的管理，避免混乱，HTTP给这些请求定义GET，POST，PUT，DELETE。而数据大小，则是因为浏览器的限制造成的。 所以GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同 隐藏的BuffGET产生一个TCP数据包，而POST产生两个TCP数据包 GET的请求，浏览器会把http header和data一并发送出去，服务器返回200（返回数据）POST的请求，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200（返回数据） 因为POST需要两步，时间上消耗的多一点，不过网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点 并不是所有浏览器POST发送两次包，Fiefox就发送一次。 最后的最后，当你以后被别人问到的时候，你就可以。。。。。。请开始你的表演 作者：以乐之名本文原创，有不当的地方欢迎指出。转载请指明出处。 参考文章：《99%的人都理解错了HTTP中GET与POST的区别》]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>WEB</tag>
      </tags>
  </entry>
</search>
